<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[OpenShift directory]]></title>
    <url>%2F2017%2F05%2F18%2FOpenShift-directory%2F</url>
    <content type="text"><![CDATA[--- title: OpenShift directory date: 2017-05-18 15:27:56 tags: OpenShift --- # Filesystem Overview [quick reference](https://developers.openshift.com/managing-your-applications/filesystem.html) ```bash . ├── app-deployments │ ├── 2017-05-16_05-41-04.349 │ ├── by-id │ └── current -> 2017-05-16_05-41-04.349 ├── app-root │ ├── build-dependencies -> runtime/build-dependencies │ ├── data │ ├── dependencies -> runtime/dependencies │ ├── logs │ ├── repo -> runtime/repo │ └── runtime ├── .auth ├── cron │ ├── bin │ ├── configuration │ ├── data │ ├── env │ ├── etc │ ├── metadata │ ├── pid │ └── run ├── .env │ ├── ciscoit-rabbitmq │ ├── mongodb │ ├── mysql │ ├── postgresql │ └── user_vars ├── gear-registry ├── .gem ├── git │ └── application-name.git ├── haproxy │ ├── bin │ ├── conf │ ├── env │ ├── hooks │ ├── metadata │ ├── run │ ├── sessions │ ├── usr -> /var/lib/openshift/.cartridge_repository/redhat-haproxy/0.0.24.2/usr │ └── versions ├── jbossews │ ├── bin │ ├── conf │ ├── env │ ├── hooks │ ├── lib -> /etc/alternatives/jbossews-2.0/lib │ ├── metadata │ ├── run │ ├── template │ ├── tmp │ ├── usr -> /var/lib/openshift/.cartridge_repository/redhat-jbossews/0.0.30.1/usr │ └── webapps -> /var/lib/openshift/application-name1-1/app-root/runtime/dependencies/jbossews/webapps ├── .m2 -> /var/lib/openshift/application-name1-1/app-root/runtime/build-dependencies/.m2 ├── .openshift_ssh ├── .sandbox ├── .ssh └── .tmp ``` --- ## .env This directory contains all the information that OpenShift provides pertaining to Environment Variables. In the directory you can find a file per environment variable containing its value. OpenShift automatically converts the information to real environment variables and you can read the values from there. --- ## app-root **app-root** is the only directory that you interact with directly (although not with all of it). There are two important directories that you should know about: **./repo** and **./data** ### repo When your application is deployed and its build built ([action hooks](https://developers.openshift.com/managing-your-applications/action-hooks.html) are being run, etc.), the code is checked out into this directory and all the required steps are run in this directory as well. For most cartridges this directory is also a working directory once the application is spun up. ### data If you create a non-scalable application, this directory can be used for persistent storage. OpenShift makes sure the data in this directory are not lost on application re-deployments, etc. This directory is represented by the OPENSHIFT_DATA_DIR environment variable. Whenever it is possible it is recommended to use the environment variable to determine the actual location of the directory. ### runtime ```bash runtime/ ├── build-dependencies ├── data -> ../data ├── dependencies │ └── jbossews │ └── webapps └── repo ``` --- ## app-deployments Deployments provide a robust feature-set for managing application deployments over time. Every time you deploy new version of your application to OpenShift, it creates a new deployment for that particular application. A deployment is a snapshot of the application that is ready to be deployed. This means that it contains a runnable application after all the hook and continuous integration tasks were run. As an example using a Java application, it will contain a WAR/EAR file that was built using Maven as part of the code push to OpenShift. All this is handled natively by the platform and does not require anything from the developer. ```bash app-deployments/ ├── 2017-05-16_05-41-04.349 │ ├── build-dependencies │ ├── dependencies │ └── repo ├── by-id │ └── dae0c37a -> ../2017-05-16_05-41-04.349 └── current -> 2017-05-16_05-41-04.349 ``` --- ## cron The jobs are organized in .openshift/cron directory of your application’s source. Depending on how often you would like to execute the job, you place them in minutely, hourly, daily, monthly, monthly. The jobs are executed directly. If it is a script, use the "shebang" line to specify the interpreter to execute it. >See also [Getting Started with Cron Jobs on OpenShift](https://blog.openshift.com/getting-started-with-cron-jobs-on-openshift) --- ## git Every OpenShift application comes with a git repository. Git is the primary way of transporting code from your machine to the platform. git contains the application source code. It is simply named after the application. You do not usually need to care about this directory. --- ## gear-registry ```bash ./ ├── gear-registry.json ├── gear-registry.json.bak └── gear-registry.lock ``` ---]]></content>
      <tags>
        <tag>OpenShift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Haskell Lesson 1]]></title>
    <url>%2F2017%2F05%2F10%2FHaskell-Lesson-1%2F</url>
    <content type="text"><![CDATA[--- title: Haskell Lesson 1 date: 2017-05-10 16:04:41 tags: --- # Exercise 1: Traffic lights > In the class, we defined a traffic light animation. Real traffic lights have an amber light in the middle. > Change the code to include the yellow light, and animate a correct sequence of traffic light signalling: > * a long green phase > * a short amber phase > * a long red phase > * a short red and amber phase1 > * back to green ```haskell {-# OPTIONS_GHC -fno-warn-warnings-deprecations -fno-warn-unused-binds #-} import CodeWorld main :: IO () main = exercise1 -- Fill in the blanks! (When I say blanks, I mean undefineds) -- Exercise 1 botCircle, midCircle, topCircle :: Color -> Picture botCircle c = colored c (translated 0 (-3) (solidCircle 1)) midCircle c = colored c (translated 0 0 (solidCircle 1)) topCircle c = colored c (translated 0 3 (solidCircle 1)) frame :: Picture frame = rectangle 2.5 9.5 trafficLight :: Integer -> Picture trafficLight 0 = botCircle green & topCircle black & midCircle black & frame -- G trafficLight 1 = botCircle black & topCircle black & midCircle yellow & frame -- Y trafficLight 2 = botCircle black & topCircle red & midCircle black & frame -- R trafficLight 3 = botCircle black & topCircle red & midCircle yellow & frame -- RY trafficController :: Double -> Picture trafficController t | round (t) `mod` 6 Make the tree bloom! Create an animation that looks like the dire tree 8 initially, and then grows blossoms at the end of each twig within 10 seconds. After 10 seconds, the tree should be in full bloom and the animation should stop. ```haskell import CodeWorld main :: IO () main = exercise2 -- Exercise 2 tree :: Integer-> Double -> Picture treeController :: Double -> Picture treeController t = tree 8 ((min t 10)/50) tree 0 t = colored yellow (solidCircle t) tree n t = path [(0,0),(0,1)] & translated 0 1 ( rotated (pi/10) (tree (n-1) t) & rotated (- pi/10) (tree (n-1) t)) exercise2 :: IO () exercise2 = animationOf treeController ```]]></content>
  </entry>
  <entry>
    <title><![CDATA[Learning Haskell]]></title>
    <url>%2F2017%2F05%2F05%2FLearning%20Haskell%2F</url>
    <content type="text"><![CDATA[--- title: Learning Haskell date: 2017-05-05 18:40:01 tags: Haskwell --- ## Learning Haskell ### Course description [CIS 194: Introduction to Haskell (Fall 2016)](https://www.seas.upenn.edu/~cis194/fall16/) Haskell is a high-level, purely functional programming language with a strong static type system and elegant mathematical underpinnings. It is being increasingly used in industry by organizations such as Facebook, AT&T, and NASA, along with several financial firms. We will explore the joys of functional programming, using Haskell as a vehicle. In the first part of the course, you will learn to use Haskell to easily and conveniently write practical programs. The last couple of weeks will consist of several special topics that explore advanced features of Haskell. Evaluation will be based on class participation, weekly programming assignments, and an open-ended final project. ### Good Haskell Style 1. DO use camelCase for function and variable names. Variant: Use ids_with_underscores for local variables only, and use camelCase for global ones. 2. DO use descriptive function names, which are as long as they need to be but no longer than they have to be. - Good: solveRemaining. - Bad: slv. - Ugly: solveAllTheCasesWhichWeHaven'tYetProcessed. 3. DON’T use tab characters. Ever. Haskell is layout-sensitive and tabs Mess Everything Up. I don’t care how you feel about tabs when coding in other languages. Just trust me on this one. Note this does not mean you need to hit space a zillion times to indent each line; your Favorite Editor ought to support auto-indentation using spaces instead of tabs. 4. DO keep lines at a natural length, and avoid long lines when it costs readability. I am not a fan of hard rules when it comes to line length, so I give you no precise number. Some lines just have to be a bit longer than usual. 5. DO give every top-level function a type signature. Type signatures enhance documentation, clarify thinking, and provide nesting sites for endangered bird species. Top-level type signatures also result in better error messages. With no type signatures, type errors tend to show up far from where the real problem is; explicit type signatures help localize type errors. Locally defined functions and constants (part of a expression or clause) do not need type signatures, but adding them doesn’t hurt (in particular, the argument above about localizing type errors still applies). 6. DO precede every top-level function by a comment explaining what it does. 7. DO use -Wall. Either pass -Wall to ghc on the command line, or (easier) put {-# OPTIONS_GHC -Wall #-} at the top of your .hs file. All your submitted programs should compile with no warnings. 8. DO, as much as possible, break up your programs into small functions that do one thing, and compose them to create more complex functions. 9. DO make all your functions total. That is, they should give sensible results (and not crash) for every input.]]></content>
      <tags>
        <tag>Haskwell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F05%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[--- title: Hello World --- Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues). ## Quick Start ### Create a new post ``` bash $ hexo new "My New Post" ``` More info: [Writing](https://hexo.io/docs/writing.html) ### Run server ``` bash $ hexo server ``` More info: [Server](https://hexo.io/docs/server.html) ### Generate static files ``` bash $ hexo generate ``` More info: [Generating](https://hexo.io/docs/generating.html) ### Deploy to remote sites ``` bash $ hexo deploy ``` More info: [Deployment](https://hexo.io/docs/deployment.html)]]></content>
  </entry>
</search>